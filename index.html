<!DOCTYPE html>
<html>



<body>

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<div id="canvDiv" class="unselectable" style="position:absolute;">
	<canvas id="backCanv" style="position: absolute; left: 0; top: 0; z-index: 0;"></canvas>
	<canvas id="midCanv" style="position: absolute; left: 0; top: 0; z-index: 1;"></canvas>
	<canvas id="frontCanv" oncontextmenu="return false;" style="position: absolute; left: 0; top: 0; z-index: 2;"></canvas>	
</div>



<script>


const DOWN = 0;
const MOVE = 1;
const UP = 2;

//const BUTTON = -1;
const outGap = 7;
const inGap = 5;
var numX = 6;
var numY = 11;
var screenL;
var screenT;
var screenW;
var screenH;
var sMaj;
var sMin;
var flipped;
const scrollAmt = 150;
var mainDiv = document.getElementById("canvDiv");
mainDiv.style.left = 0 + 'px';
mainDiv.style.top = 0 + 'px';
var backCanv = document.getElementById("backCanv");
var backCx = backCanv.getContext("2d");
var midCanv = document.getElementById("midCanv");
var midCx = midCanv.getContext("2d");
var frontCanv = document.getElementById("frontCanv");
var frontCx = frontCanv.getContext("2d");
midCx.fillStyle = 'RGB(25,124,247)';
backCx.fillStyle = 'RGB(0,0,0)';
document.addEventListener("touchstart", updateClickM);
document.addEventListener("touchend", updateClickM);
document.addEventListener("touchmove", updateClickM);

document.addEventListener("mousedown", updateClickM);
document.addEventListener("mousemove", updateClickM);
document.addEventListener("mouseup", updateClickM);

var curRow = null;
var curCol = null;

const BUTTON = -1;
const ZOOM = 2; 
const TARGET = 3;
var act = null;
/* function updateClick(e)
{
	if(e.type === "touchend" || !(e.touches)) act = null;
	else act = BUTTON; 

	
} */

function updateClickM(e)
{
	//console.log(e);
	//ignore defaults if we're not zooming
	//if(act !== ZOOM) e.preventDefault();
	
	//get the position
	var XY = getXY(e);
	
	//check for new event
	if(XY[2] === DOWN)
	{
		console.log('down');
		//check for button
		if(XY[1] >= sMaj - butS)
		{
			act = BUTTON;
			console.log('but');

			//check for zoom button
			if(!butts[Math.floor(XY[0]/butS)].prevent)
			{
				console.log('zoom');
				act = ZOOM;
				window.scrollTo(0, 0);
				reConfigure();
			}			
		}
		//otherwise it's a new target
		else
		{
			console.log('board');
			act = TARGET;
		}
	}
	
	//check for event end, apply whatever is necessary
	if(XY[2] === UP)
	{		
		if(!act === ZOOM && curRow !== null && curCol !== null)
		{
			if(act === TARGET)
			{
				
			}
			else
			{
				
			}
		}
		curRow = null;
		curCol = null;
		console.log('up');
		act = null;
	}
	
	//otherwise, it's a start or move, update where we're at
	else
	{
		//zoom-- make sure it's highlighted regardless of position
		if(act === ZOOM)
		{
			curRow = BUTTON;
			curCol = ZOOM_COL;
		}
		else
		{
			
			curRow = null;
			curCol = null;
			
			if(act === BUTTON && XY[1] >= sMaj - butS)
			{
				curRow = BUTTON;
				curCol = Math.floor(XY[0]/butS);
				if(curCol === ZOOM_COL)
				{
					console.log('bad zoom');
					curCol = null;
				}
			}
			else if(act === TARGET && XY[0] > startMin && XY[0] < sMin - startMin && 
				XY[1] > startMaj && XY[1] < sMaj - butS - startMaj)
			{
				curCol = Math.floor((XY[0] - startMin)/(boxS + inGap));
				curRow = Math.floor((XY[1] - startMaj)/(boxS + inGap));
				
			}
		}
	}
	console.log(act);
}




function updateClick(e)
{
	//ignore defaults if we're not zooming
	if(act !== ZOOM) e.preventDefault();
	
	//get the position
	var XY = getXY(e);
	
	//check for new event
	if(e.type === "touchstart")
	{
		//check for button
		if(curY >= sMaj - butS)
		{
			act = BUTTON;

			//check for zoom button
			if(!butts[Math.floor(curX/butS)].prevent)
			{
				
				act = ZOOM;
				window.scrollTo(0, 0);
				reConfigure();
			}			
		}
		//otherwise it's a new target
		else
		{
			act = TARGET;
		}
	}
	
	//check for event end, apply whatever is necessary
	if(e.type === "touchend" || !(e.touches))
	{		
		if(!act === ZOOM && curRow !== null && curCol !== null)
		{
			if(act === TARGET)
			{
				
			}
			else
			{
				
			}
		}
		curRow = null;
		curCol = null;
		act = null;
	}
	
	//otherwise, it's a start or move, update where we're at
	else
	{
		//zoom-- make sure it's highlighted regardless of position
		if(act === ZOOM)
		{
			curRow = BUTTON;
			curCol = ZOOM_COL;
		}
		else
		{
			
			curRow = null;
			curCol = null;
			
			if(act === BUTTON && curY >= sMaj - butS)
			{
				curRow = BUTTON;
				curCol = Math.floor(curX/butS);
				if(curCol === ZOOM_COL) curCol == null;
			}
			else if(act === TARGET && curX > startMin && curX < sMin - startMin && 
				curY > startMaj && curY < sMaj - butS - startMaj)
			{
				curCol = Math.floor((curX - startMin)/(boxS + inGap));
				curRow = Math.floor((curY - startMaj)/(boxS + inGap));
				
			}
		}
	}
}



function getXY(e)
{
	var x;
	var y;
	var type;
	
	if(e.type.substr(0, 5) === 'mouse') 
	{
		switch(e.type)
		{
			case 'mousedown': type = DOWN; break;
			case 'mousemove': type = MOVE; break;
			case 'mouseup': type = UP; break;	
		}
		x = event.clientX;
		y = event.clientY;
		
	}
	else
	{
		switch(e.type)
		{
			case 'touchstart': type = DOWN; break;
			case 'touchmove': type = MOVE; break;
			case 'touchend': return [0, 0, UP]; break;
		}
		x = e.touches[0].pageX;
		y = e.touches[0].pageY;
		
	}
	
	if(flipped) 
	{
		return [sMin - (y - screenT), x - screenL, type];
	}
	else
	{
		return [x - screenT, y - screenL, type];
	}
}


/* function updateClick(e)
{
	if(e.type === "touchend" || !(e.touches))
	{
		toggling = false;
		
		//do action if applicable
		if(curRow !== null && curCol !== null)
		{
			
		}
		curRow = null;
		curCol = null;
	}
	else
	{
		curRow = null;
		curCol = null;
		var curX, curY;
		
		if(flipped) 
		{
			curX = sMin - (e.touches[0].pageY - screenT);
			curY = e.touches[0].pageX - screenL;
		}
		else
		{
			curX = e.touches[0].pageX - screenL;
			curY = e.touches[0].pageY - screenT;
		}
		
		//on button target
		if(curY >= sMaj - butS)
		{
			curRow = BUTTON;
			if(butS) curCol = Math.floor(curX/butS);
			
			if(e.type === "touchstart" && !butts[curCol].prevent)
			{
				toggling = true;
				window.scrollTo(0, 0);
				reConfigure();
			}
			
		}
	
		//on grid target
		else if(curX > startMin && curX < sMin - startMin && 
				curY > startMaj && curY < sMaj - butS - startMaj)
		{
			curCol = Math.floor((curX - startMin)/(boxS + inGap));
			curRow = Math.floor((curY - startMaj)/(boxS + inGap));
			
		}
	}
	if(!toggling) e.preventDefault();
} */
function reConfigure()
{
	screenT = (window.pageYOffset || document.documentElement.scrollTop);
	window.scrollTo(0, (screenT)? scrollAmt: 0);
	
	screenT = (window.pageYOffset || document.documentElement.scrollTop);
	screenL = (window.pageXOffset || document.documentElement.scrollLeft);
	
	screenW = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);
	screenH = (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight);
	backCanv.width = screenW + scrollAmt;
	backCanv.height = screenH +  scrollAmt;
	midCanv.width = screenW + scrollAmt;
	midCanv.height = screenH + scrollAmt;
	frontCanv.width = screenW + scrollAmt;
	frontCanv.height = screenH + scrollAmt;
	backCx.restore();
	midCx.restore();
	frontCx.restore();
	backCx.save();
	midCx.save();
	frontCx.save();
	sMaj = Math.max(screenW, screenH);
	sMin = Math.min(screenW, screenH);
	flipped = (screenW > screenH);
	
	butS = sMin / butts.length;
	boxS = Math.min((sMaj - butS - 2 * outGap - (numY-1) * inGap)/numY, 
					(sMin - 2 * outGap - (numX-1) * inGap)/numX);
					
	startMin = (sMin - boxS * numX - (numX - 1) * inGap)/2;
	startMaj = (sMaj - butS - boxS * numY - (numY -1) * inGap)/2;
	
	drawBase();
}
	
function drawBase()
{
	backCx.clearRect(0, 0, backCanv.width, backCanv.height);
	frontCx.clearRect(0, 0, backCanv.width, backCanv.height);
	
	backCx.translate(0, screenT);
	frontCx.translate(0, screenT);
	midCx.translate(0, screenT);
	
	midCx.fillStyle = 'RGB(25,124,247)';
	
	if(flipped)
	{
		backCx.rotate(-Math.PI/2);
		backCx.translate(-sMin, 0);
		
		midCx.rotate(-Math.PI/2);
		midCx.translate(-sMin, 0);
		
	}
	for(var i = 0; i < butts.length; i += 1)
	{
		
		
		if(!flipped)
		{
			frontCx.drawImage(butImg, butts[i].imgInd * butImg.height, 0, butImg.height, butImg.height,
				butS * i, sMaj - butS, butS, butS);
		}
		else
		{
			frontCx.drawImage(butImg, butts[i].imgInd * butImg.height, 0, butImg.height, butImg.height,
						 sMaj - butS, sMin - butS * (i + 1), butS, butS);
		}
	}
	
		
	for(var i = 0; i < numX; i += 1)
	{
		for(var j = 0; j < numY; j += 1)
		{
			backCx.fillRect(startMin + i * (boxS + inGap), startMaj + j * (boxS + inGap), boxS, boxS);
		}
	}
	
	//drawPicker();	
	
	
}
var minR = 30;
var cX = sMin/2;
var cY = sMaj/2;
function drawPicker()
{
	backCx.fillStyle = 'RGB(100,100,100)';
	backCx.strokeStyle = 'RGB(100, 100, 100)';
	backCx.beginPath();
	
	cX = sMin/2;
	cY = sMaj/2;
	var gap = 3;
	var halfGap = gap/2;
	
	//backCx.globalAlpha = .8;
	backCx.fillStyle = 'RGB(200,200,200)';
	backCx.strokeStyle = 'RGB(0,0,0)';
	backCx.lineWidth = gap;
	backCx.arc(cX, cY, minR * 3, 0, 2 * Math.PI);
	backCx.fill();
	backCx.stroke();
	backCx.beginPath();
	backCx.arc(cX, cY, minR * 2, 0, 2 * Math.PI);
	backCx.stroke();
	
	for(var grp = 0; grp < 2; grp+= 1)
	{
		var outR;
		var inR;
		
		if(!grp)
		{
			outR = 2 * minR - halfGap;
			inR = minR + halfGap;
		}
		else
		{
			outR = 3 * minR - gap;
			inR = 2 * minR + halfGap;
		}
		var theta = Math.PI/8;
		var thetaInc = Math.PI/4;
		
		for(var slice = 0; slice < 4; slice+=1 )
		{
			theta += thetaInc;
			var dX = 3 * minR * Math.cos(theta);
			var dY = 3 * minR * Math.sin(theta);
			backCx.beginPath();
			backCx.moveTo(cX + dX, cY - dY);
			backCx.lineTo(cX - dX, cY + dY);
			backCx.stroke();
		}
	}
	
	backCx.beginPath();
	backCx.arc(cX, cY, minR, 0, 2 * Math.PI);
	backCx.fill();
	backCx.stroke();
}

var k = 0;

function animate()
{
	
	
	var curL = (window.pageXOffset || document.documentElement.scrollLeft);
	var curT = (window.pageYOffset || document.documentElement.scrollTop);
	var curW = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);
	var curH = (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight);
	
	if(act !== ZOOM && (curL !== screenL || curT !== screenT || curW !== screenW || curH !== screenH))
	{
		console.log('change');
		reConfigure();
	}
	
	midCx.clearRect(0,0,sMin, sMaj);
	
	if(curRow !== null && curCol !== null)
	{
		midCxfont="30px";
		midCx.strokeText(curRow + ', ' + curCol, 2, 10);
		if(curRow === BUTTON)
		{
			midCx.fillRect(curCol * butS, sMaj - butS, butS, butS);
		}
		else
		{
			midCx.fillRect(startMin + curCol * (boxS + inGap), startMaj + curRow * (boxS + inGap), boxS, boxS);
		}
	}	
/* 	midCx.clearRect(0,0, sMin, sMaj);
	k++;
	k = k % 5;
	//console.log(act);
	var t = (act === null)? 0: 2;
	midCx.fillStyle = 'rgb(90,90,90)';
	midCx.fillRect(t * butS, sMaj - butS, butS, butS); */
	//console.log(l);
		
	requestAnimationFrame(animate);
}
var scrnBut = {
	prevent: false,
	imgInd: 0,
	action: function(){
		//do nothing
	}
};
var ZOOM_COL = 0;
var menuBut = {
	prevent: true,
	imgInd: 1,
	action: function(){
		//load menu
	}
};
var restartBut = {
	prevent: true,
	imgInd: 2,
	action: function(){
		loadLevel(false);
	}
};
var undoBut = {
	prevent: true,
	imgInd: 3,
	action: function(){
		//undo
	}
};
var hintsBut = {
	prevent: true,
	imgInd: 4,
	action: function(){
		//toggle hints
	}
};
var butts = [scrnBut, menuBut, restartBut, undoBut, hintsBut]; 
var butImg = document.createElement("img");
butImg.onload = function() 
{
	setTimeout(function () 
	{
		backCx.save();
		/* for(var i = 0; i < butts.length; i += 1)
		{
			console.log(butts[i].prevent);
		} */
		animate();
	}, 300);
/* 	loaded += 1;
	if(loaded == 1) startIt(); */
}
butImg.src = "buttons.png";
</script>

</body>

</html> 