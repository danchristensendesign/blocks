<!DOCTYPE html>
<html>



<body>

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<div id="canvDiv" class="unselectable" style="position:absolute; left: 0, top: 0;">

</div>



<script>
const outGap = 7;
const inGap = 5;

const BACK = 0;
const MID = 1;
const FRONT = 2;

const CLICK_START = 0;
const CLICK_MOVE = 1;
const CLICK_END = 2;

const SELECT_BUT = -1;
const SELECT_ZOOM = 2; 
const SELECT_MOVE = 3;

var flipped;
var mobile = false;
var fullS = false;
var scrollAmt = 150;
var SELECT_ZOOM_COL = 0;

var canv = [];
var cx = [];

var numX = 6;
var numY = 11;

var scrn = {
	L: 0,
	T: 0,
	W: 0,
	H: 0,
	maj: 0,
	min: 0, 
	but: 0,
	box: 0
}
var mainDiv = document.getElementById("canvDiv");
mainDiv.style.left = 0 + 'px';
mainDiv.style.top = 0 + 'px';

/* var canv[BACK] = document.getElementById("canv[BACK]");
var cx[BACK] = canv[BACK].getContext("2d");
var canv[MID] = document.getElementById("canv[MID]");
var cx[MID] = canv[MID].getContext("2d");
var canv[FRONT] = document.getElementById("canv[FRONT]");
var cx[FRONT] = canv[FRONT].getContext("2d");

*/
document.addEventListener("touchstart", startClick);
document.addEventListener("touchend", endClick);
document.addEventListener("touchmove", moveClick, {passive: false});

document.addEventListener("mousedown", startClick);
document.addEventListener("mousemove", moveClick);
document.addEventListener("mouseup", endClick);

var curRow = null;
var curCol = null;


var act = null;
/* function updateClick(e)
{
	if(e.type === "touchend" || !(e.touches)) act = null;
	else act = SELECT_BUT; 

	
} */
var targCen = [null, null];
var targPos = [null, null];
const targCircR = 35;
const targInR = 75;
const targOutR = 110;

var pos = [2,2];




function startClick(e)
{
	//check for mobile vs computer
	mobile = e.type.indexOf('touch') > -1;
	
	//set XY
	var XY = getXY(e);
	
	//check for button
	if(XY[1] >= scrn.maj - scrn.but)
	{
		//check for zoom button
		if(Math.floor(XY[0]/scrn.but) === SELECT_ZOOM_COL)
		{
			act = SELECT_ZOOM;
			window.scrollTo(0, 0);
			reConfigure();
		}	
		else
		{
			act = SELECT_BUT;
		}
	}
	//otherwise it's a new target
	else
	{
		targCen = XY.slice(0, 2);
		console.log('board');
		act = SELECT_MOVE;
	}
	
	//update target
	updateClick(XY);	
	
}

function moveClick(e)
{
	//prevent default action if we're not zooming
	if(act !== SELECT_ZOOM) e.preventDefault();
	updateClick(getXY(e));
}

function getXY(e)
{
	var XY = [];
	
	if(mobile)
	{
		XY[0] = e.touches[e.touches.length -1].clientX;
		XY[1] = e.touches[e.touches.length -1].clientY;
	}
	else
	{
		XY[0] = e.clientX;
		XY[1] = e.clientY;
	}
		
		
	if(flipped) 
	{
		var t = XY[0];
		XY[0] = scrn.min - XY[1];
		XY[1] = t;
	}
	return XY;
}
	
function updateClick(XY)
{


	//update positions
	if(act === SELECT_ZOOM)
	{
		curRow = SELECT_BUT;
		curCol = SELECT_ZOOM_COL;
	}
	else
	{
		
		curRow = null;
		curCol = null;
		
		if(act === SELECT_BUT)
		{
			if(XY[1] >= (scrn.maj - scrn.but))
			{
				curRow = SELECT_BUT;
				curCol = Math.floor(XY[0]/scrn.but);
				console.log(curRow + ', ' + curCol + act);//XY[1] + ', poop ' + (scrn.maj - scrn.but));
				if(curCol === SELECT_ZOOM_COL)
				{
					curCol = null;
				}
			}
		}
		else if(act === SELECT_MOVE)
		{
			targPos = XY.slice(0, 2);
		}
	}
}


function endClick(e)
{
	//zoom
	if(act === SELECT_ZOOM)
	{
		fullS = !fullS;
		var elem = document.documentElement;

		//toggle fullscreen (doesn't work on all platforms) 
		if(fullS)
		{
		  if (elem.requestFullscreen) elem.requestFullscreen();
		  else if (elem.mozRequestFullScreen) elem.mozRequestFullScreen();
		  else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
		  else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
		}
		else
		{
			if (document.exitFullscreen) document.exitFullscreen();
			else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
			else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
			else if (document.msExitFullscreen)  document.msExitFullscreen();
		}
	}
	else if(curRow !== null && curCol !== null)
	{
		//make a move
		if(act === SELECT_MOVE)
		{
			
		}
		//button clicks
		else 
		{
			
		}
	}
	
	//reset place holders/action status
	curRow = null;
	curCol = null;
	act = null;
		return;
}










function reConfigure()
{
	if(!mobile) scrollAmt = 0;
	scrn.T = (window.pageYOffset || document.documentElement.scrollTop);
	window.scrollTo(0, (scrn.T)? scrollAmt: 0);
	
	scrn.T = (window.pageYOffset || document.documentElement.scrollTop);
	scrn.l = (window.pageXOffset || document.documentElement.scrollLeft);
	
	scrn.w = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);
	scrn.h = (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight);
	canv[BACK].width = scrn.w + scrollAmt;
	canv[BACK].height = scrn.h +  scrollAmt;
	canv[MID].width = scrn.w + scrollAmt;
	canv[MID].height = scrn.h + scrollAmt;
	canv[FRONT].width = scrn.w + scrollAmt;
	canv[FRONT].height = scrn.h + scrollAmt;
	cx[BACK].restore();
	cx[MID].restore();
	cx[FRONT].restore();
	cx[BACK].save();
	cx[MID].save();
	cx[FRONT].save();
	scrn.maj = Math.max(scrn.w, scrn.h);
	scrn.min = Math.min(scrn.w, scrn.h);
	flipped = (scrn.w > scrn.h);
	
	scrn.but = scrn.min / butts.length;
	scrn.sq = Math.min((scrn.maj - scrn.but - 2 * outGap - (numY-1) * inGap)/numY, 
					(scrn.min - 2 * outGap - (numX-1) * inGap)/numX);
					
	startMin = (scrn.min - scrn.sq * numX - (numX - 1) * inGap)/2;
	startMaj = (scrn.maj - scrn.but - scrn.sq * numY - (numY -1) * inGap)/2;
	
	drawBase();
}
	
function drawBase()
{
	cx[BACK].clearRect(0, 0, canv[BACK].width, canv[BACK].height);
	cx[FRONT].clearRect(0, 0, canv[BACK].width, canv[BACK].height);
	
	cx[BACK].translate(0, scrn.T);
	cx[FRONT].translate(0, scrn.T);
	cx[MID].translate(0, scrn.T);
	
	cx[MID].fillStyle = 'RGB(25,124,247)';
	
	if(flipped)
	{
		cx[BACK].rotate(-Math.PI/2);
		cx[BACK].translate(-scrn.min, 0);
		
		cx[MID].rotate(-Math.PI/2);
		cx[MID].translate(-scrn.min, 0);
		
	}
	for(var i = 0; i < butts.length; i += 1)
	{
		
		
		if(!flipped)
		{
			cx[FRONT].drawImage(butImg, butts[i].imgInd * butImg.height, 0, butImg.height, butImg.height,
				scrn.but * i, scrn.maj - scrn.but, scrn.but, scrn.but);
		}
		else
		{
			cx[FRONT].drawImage(butImg, butts[i].imgInd * butImg.height, 0, butImg.height, butImg.height,
						 scrn.maj - scrn.but, scrn.min - scrn.but * (i + 1), scrn.but, scrn.but);
		}
	}
	
		
	for(var i = 0; i < numX; i += 1)
	{
		for(var j = 0; j < numY; j += 1)
		{
			cx[BACK].fillRect(startMin + i * (scrn.sq + inGap), startMaj + j * (scrn.sq + inGap), scrn.sq, scrn.sq);
		}
	}
	
	//drawPicker();	
	
	
}
var minR = 30;
var cX = scrn.min/2;
var cY = scrn.maj/2;


var k = 0;

function animate()
{
	
	
	var curL = (window.pageXOffset || document.documentElement.scrollLeft);
	var curT = (window.pageYOffset || document.documentElement.scrollTop);
	var curW = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);
	var curH = (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight);
	
	if(act !== SELECT_ZOOM && (curL !== scrn.l || curT !== scrn.T || curW !== scrn.w || curH !== scrn.h))
	{
		console.log('change');
		reConfigure();
	}
	
	cx[MID].clearRect(0,0,scrn.min, scrn.maj);
	cx[MID].fillStyle = 'RGB(25,124,247)';
	if(act !== null)
	{
		midCxfont="30px";
		
		if(act === SELECT_BUT || act === SELECT_ZOOM)
		{
			if(curRow === SELECT_BUT && curCol !== null)
			{
				cx[MID].fillRect(curCol * scrn.but, scrn.maj - scrn.but, scrn.but, scrn.but);
			}
		}
		else
		{
			drawTarget();
			if(0 === 1)
			{
				
				
				const targCircT = 30;//(!mobile)? scrn.sq/2: scrn.sq/2*3;
				console.log(targCircT);
				const targInT = targCircT + 30;// + scrn.sq;
				const targOutT = targInT + 20;// 2.7;//;
				const adder = targCircT * .3;
				const liner = adder * .3;
				const overAng = Math.PI/12;
				const underAng = Math.PI/20 * .5;
				
				/* for(var s = 0; s < 8; s+= 1)
				{
					for(var r = 1; r < 3; r += 1)
					{
						var cos = Math.cos(s * Math.PI/4);
						var xSgn = (cos > 0)? 1: -1;
						var xVal = ((Math.abs(cos) > .7)? r: 0) * xSgn;
						var sin = Math.sin(s * Math.PI/4);
						var ySgn = (sin > 0)? 1: -1;
						var yVal = ((Math.abs(sin) > .7)? r: 0) * ySgn;
						cx[MID].fillRect(startMin + (pos[0] + xVal) * (scrn.sq + inGap), startMaj + (pos[1] + yVal) * (scrn.sq + inGap), scrn.sq, scrn.sq);
					}
				} */
				
						
						
				var dist = distance(targPos, targCen);
				var rC = scrn.sq/2;
				var ri = rC + scrn.sq;
				var ro = ri + scrn.sq;
				var theta = Math.atan2(targPos[1]-targCen[1], targPos[0]-targCen[0]);
				if(theta < 0) theta += Math.PI * 2;
				theta += Math.PI/8;
				var sect = Math.floor(theta/(Math.PI/4))%8;
				var sAng = -Math.PI/8 + sect * Math.PI/4;
				var eAng = sAng + Math.PI/4;
				var oR = 0;
				var iR = 0
				var scl;
				if(dist < targCircT)
				{
					scl = 0;
				}
				else if(dist < targInT)
				{
					scl = 1;	
				}
				else if(dist < targOutT) 
				{
					scl = 2;
				}
				var cos = Math.cos(sect * Math.PI/4);
				var xSgn = (cos > 0)? 1: -1;
				var xVal = ((Math.abs(cos) > .7)? scl: 0) * xSgn;
				var sin = Math.sin(sect * Math.PI/4);
				var ySgn = (sin > 0)? 1: -1;
				var yVal = ((Math.abs(sin) > .7)? scl: 0) * ySgn;
				cx[MID].fillStyle = 'RGB(255,255,255)';
				cx[MID].fillRect(startMin + (pos[0] + xVal) * (scrn.sq + inGap), startMaj + (pos[1] + yVal) * (scrn.sq + inGap), scrn.sq, scrn.sq);
				
				cx[MID].fillStyle = 'RGB(25,124,247)';
				cx[MID].beginPath();
				cx[MID].arc(targCen[0], targCen[1], oR, sAng, eAng);
				cx[MID].arc(targCen[0], targCen[1], iR, eAng, sAng, true);
				cx[MID].fill();
				
				cx[MID].beginPath();
				cx[MID].arc(targCen[0], targCen[1], targCircT, 0, 2 * Math.PI);
				cx[MID].stroke();
				cx[MID].lineWidth = 3;
				cx[MID].fillStyle = 'RGB(255,255,255)';
				cx[MID].fillStyle = 'RGB(75,180,247)';
				for(var s = 0; s < 8; s+= 1)
				{
					for(var r = 0; r < 2; r += 1)
					{
						var or, ir;
						if(!r)
						{
							or = targInT - liner;
							ir = targCircT + liner;
							cx[MID].fillStyle = 'RGB(120, 120, 120)';
						}
						else
						{
							or = targOutT - liner;
							ir = targInT + liner;
							cx[MID].fillStyle = 'RGB(201, 201, 201)';
						}
						var sang = -Math.PI/8 + s * Math.PI/4 + underAng;
						var eang = sang + Math.PI/4 - underAng;
						cx[MID].beginPath();
						cx[MID].arc(targCen[0], targCen[1], or, sang, eang);
						cx[MID].arc(targCen[0], targCen[1], ir, eang, sang, true);
						cx[MID].globalAlpha = .7;
						cx[MID].fill();
						/* cx[MID].globalAlpha = 1;
						cx[MID].stroke(); */
					}
				}
				var dist = distance(targPos, targCen);
				
				
				//cx[MID].strokeText(targCen[0] + ', ' + targCen[1], 2, 10);
				
				
				
				var theta = Math.atan2(targPos[1]-targCen[1], targPos[0]-targCen[0]);
				if(theta < 0) theta += Math.PI * 2;
				theta += Math.PI/8;
				var sect = Math.floor(theta/(Math.PI/4))%8;
				var sAng = -Math.PI/8 + sect * Math.PI/4 ;
				var eAng = sAng + Math.PI/4 ;
				var oR = 0;
				var iR = 0
				if(dist < targCircT)
				{
					sAng = 0;
					eAng = 2 * Math.PI;
					oR = targCircT;
					iR = 0;
				}
				else if(dist < targInT)
				{
					var ot = overAng * 3/2;
					sAng -= ot;
					eAng += ot; 
					oR = targInT + adder;// * 1.1;
					iR = targCircT - adder;//* .9;	
				}
				else if(dist < targOutT) 
				{
					var ot = overAng;
					sAng -= ot;
					eAng +=  ot; 
					oR = targOutT  + adder;//* 1.1;
					iR = targInT - adder;//* .9;

				}
				cx[MID].fillStyle = 'RGB(255,255,255)';
				cx[MID].globalAlpha = .7;//'RGB(255,255,255)';
				cx[MID].beginPath();
				cx[MID].arc(targCen[0], targCen[1], targCircT-liner, 0, 2 * Math.PI);
				cx[MID].fill();
				cx[MID].fillStyle = 'black';
				cx[MID].globalAlpha = 1;
				cx[MID].stroke();
				cx[MID].lineWidth = 3;
				cx[MID].fillStyle = 'RGB(255,255,255)';
				
				cx[MID].fillStyle = 'RGB(25,124,247)';
				cx[MID].beginPath();
				cx[MID].arc(targCen[0], targCen[1], oR, sAng, eAng);
				cx[MID].arc(targCen[0], targCen[1], iR, eAng, sAng, true);
				cx[MID].fill();
				
				
				/* for(var s = 0; s < 8; s+= 1)
				{
					for(var r = 0; r < 2; r += 1)
					{
						var or, ir;
						if(!r)
						{
							or = targInR;
							ir = targCircR;
						}
						else
						{
							or = targOutR;
							ir = targInR;
						}
						var sang = -Math.PI/8 + s * Math.PI/4;
						var eang = sang + Math.PI/4;
						cx[MID].beginPath();
						cx[MID].arc(targCen[0], targCen[1], or, sang, eang);
						cx[MID].arc(targCen[0], targCen[1], ir, eang, sang, true);
						cx[MID].globalAlpha = .3;
						cx[MID].fill();
						cx[MID].globalAlpha = 1;
						cx[MID].stroke();
					}
				} */
				
				
				
				
				//cx[MID].fillRect(startMin + curCol * (scrn.sq + inGap), startMaj + curRow * (scrn.sq + inGap), scrn.sq, scrn.sq);
			}
		}
	}
	cx[MID].fillStyle = 'RGB(25,124,247)';
	cx[MID].fillRect(startMin + pos[1] * (scrn.sq + inGap), startMaj + pos[0] * (scrn.sq + inGap), scrn.sq, scrn.sq);	
/* 	cx[MID].clearRect(0,0, scrn.min, scrn.maj);
	k++;
	k = k % 5;
	//console.log(act);
	var t = (act === null)? 0: 2;
	cx[MID].fillStyle = 'rgb(90,90,90)';
	cx[MID].fillRect(t * scrn.but, scrn.maj - scrn.but, scrn.but, scrn.but); */
	//console.log(l);
		
	requestAnimationFrame(animate);
}

function drawTarget()
{
	const targCircT = 30;//(!mobile)? scrn.sq/2: scrn.sq/2*3;
	console.log(targCircT);
	const targInT = targCircT + 30;// + scrn.sq;
	const targOutT = targInT + 20;// 2.7;//;
	const adder = targCircT * .3;
	const liner = adder * .3;
	const overAng = Math.PI/12;
	const underAng = Math.PI/20 * .5;
			
			
	var dist = distance(targPos, targCen);
	var rC = scrn.sq/2;
	var ri = rC + scrn.sq;
	var ro = ri + scrn.sq;
	var theta = Math.atan2(targPos[1]-targCen[1], targPos[0]-targCen[0]);
	if(theta < 0) theta += Math.PI * 2;
	theta += Math.PI/8;
	var sect = Math.floor(theta/(Math.PI/4))%8;
	var sAng = -Math.PI/8 + sect * Math.PI/4;
	var eAng = sAng + Math.PI/4;
	var oR = 0;
	var iR = 0
	var scl;
	if(dist < targCircT)
	{
		scl = 0;
	}
	else if(dist < targInT)
	{
		scl = 1;	
	}
	else if(dist < targOutT) 
	{
		scl = 2;
	}
	var cos = Math.cos(sect * Math.PI/4);
	var xSgn = (cos > 0)? 1: -1;
	var xVal = ((Math.abs(cos) > .7)? scl: 0) * xSgn;
	var sin = Math.sin(sect * Math.PI/4);
	var ySgn = (sin > 0)? 1: -1;
	var yVal = ((Math.abs(sin) > .7)? scl: 0) * ySgn;
	cx[MID].fillStyle = 'RGB(255,255,255)';
	cx[MID].fillRect(startMin + (pos[0] + xVal) * (scrn.sq + inGap), startMaj + (pos[1] + yVal) * (scrn.sq + inGap), scrn.sq, scrn.sq);
	dist = Math.min(70, dist);
	theta -= Math.PI/8;
	//theta = sect * Math.PI/4;
	var realPos = [targCen[0] + dist * Math.cos(theta), targCen[1] + dist * Math.sin(theta)];
	var stem = 40;
	cx[MID].beginPath();
	cx[MID].moveTo(targCen[0], targCen[1]);
	cx[MID].lineTo(realPos[0], realPos[1]);
	cx[MID].lineWidth = stem;
	cx[MID].strokeStyle = 'rgb(150,150,150)';
	cx[MID].stroke();
	cx[MID].beginPath();
	cx[MID].fillStyle = 'rgb(150,150,150)';
	cx[MID].arc(targCen[0], targCen[1], stem/2, 0, 2 * Math.PI);
	cx[MID].fill();
	
	cx[MID].save();
	
	cx[MID].translate(realPos[0], realPos[1], targPos[1]);
	
	//
	
	
	cx[MID].rotate(theta);// -Math.PI/8);
	var distort = interpLog(5, dist + 5, 75, 1, .5);
	cx[MID].scale(distort, 1);
	
	cx[MID].beginPath();
	cx[MID].fillStyle = 'rgb(150,150,150)';
	cx[MID].arc(0, 0, 70, 0, 2 * Math.PI);
	cx[MID].fill();
	cx[MID].restore();
	cx[MID].lineWidth = 10;
	cx[MID].strokeStyle = 'rgb(50,50,50)';
	cx[MID].stroke();
	
	//portal target
	/* cx[MID].fillStyle = 'RGB(25,124,247)';
	cx[MID].beginPath();
	cx[MID].arc(targCen[0], targCen[1], oR, sAng, eAng);
	cx[MID].arc(targCen[0], targCen[1], iR, eAng, sAng, true);
	cx[MID].fill();
	
	cx[MID].beginPath();
	cx[MID].arc(targCen[0], targCen[1], targCircT, 0, 2 * Math.PI);
	cx[MID].stroke();
	cx[MID].lineWidth = 3;
	cx[MID].fillStyle = 'RGB(255,255,255)';
	cx[MID].fillStyle = 'RGB(75,180,247)';
	for(var s = 0; s < 8; s+= 1)
	{
		for(var r = 0; r < 2; r += 1)
		{
			var or, ir;
			if(!r)
			{
				or = targInT - liner;
				ir = targCircT + liner;
				cx[MID].fillStyle = 'RGB(120, 120, 120)';
			}
			else
			{
				or = targOutT - liner;
				ir = targInT + liner;
				cx[MID].fillStyle = 'RGB(201, 201, 201)';
			}
			var sang = -Math.PI/8 + s * Math.PI/4 + underAng;
			var eang = sang + Math.PI/4 - underAng;
			cx[MID].beginPath();
			cx[MID].arc(targCen[0], targCen[1], or, sang, eang);
			cx[MID].arc(targCen[0], targCen[1], ir, eang, sang, true);
			cx[MID].globalAlpha = .7;
			cx[MID].fill();

		}
	}
	var dist = distance(targPos, targCen);
	
	
	//cx[MID].strokeText(targCen[0] + ', ' + targCen[1], 2, 10);
	
	
	
	var theta = Math.atan2(targPos[1]-targCen[1], targPos[0]-targCen[0]);
	if(theta < 0) theta += Math.PI * 2;
	theta += Math.PI/8;
	var sect = Math.floor(theta/(Math.PI/4))%8;
	var sAng = -Math.PI/8 + sect * Math.PI/4 ;
	var eAng = sAng + Math.PI/4 ;
	var oR = 0;
	var iR = 0
	if(dist < targCircT)
	{
		sAng = 0;
		eAng = 2 * Math.PI;
		oR = targCircT;
		iR = 0;
	}
	else if(dist < targInT)
	{
		var ot = overAng * 3/2;
		sAng -= ot;
		eAng += ot; 
		oR = targInT + adder;// * 1.1;
		iR = targCircT - adder;//* .9;	
	}
	else if(dist < targOutT) 
	{
		var ot = overAng;
		sAng -= ot;
		eAng +=  ot; 
		oR = targOutT  + adder;//* 1.1;
		iR = targInT - adder;//* .9;

	}
	cx[MID].fillStyle = 'RGB(255,255,255)';
	cx[MID].globalAlpha = .7;//'RGB(255,255,255)';
	cx[MID].beginPath();
	cx[MID].arc(targCen[0], targCen[1], targCircT-liner, 0, 2 * Math.PI);
	cx[MID].fill();
	cx[MID].fillStyle = 'black';
	cx[MID].globalAlpha = 1;
	cx[MID].stroke();
	cx[MID].lineWidth = 3;
	cx[MID].fillStyle = 'RGB(255,255,255)';
	
	cx[MID].fillStyle = 'RGB(25,124,247)';
	cx[MID].beginPath();
	cx[MID].arc(targCen[0], targCen[1], oR, sAng, eAng);
	cx[MID].arc(targCen[0], targCen[1], iR, eAng, sAng, true);
	cx[MID].fill(); */
	
}

function interp(xmin, x, xmax, ymin, ymax)
{
	if(xmax == xmin) return 0;
	else return ymin + (ymax - ymin) * (x - xmin)/(xmax - xmin);
}

function interpLog(xmin, x, xmax, ymin, ymax)
{
	var fact = 3;
	xmin = Math.pow(xmin, fact);//log(xmin);
	xmax = Math.pow(xmax, fact);Math.log(xmax);
	x = Math.pow(x, fact);Math.log(x);
	console.log(xmin + ', ' + x + ', ' + xmax);
	
	if(xmax == xmin) return 0;
	else return ymin + (ymax - ymin) * (x - xmin)/(xmax - xmin);
}
function distance(arr1, arr2)
{
	return Math.pow(Math.pow(arr1[0] - arr2[0], 2) + Math.pow(arr1[1] - arr2[1], 2) ,.5);
}
var scrnBut = {
	imgInd: 0,
	action: function(){
		//do nothing
	}
};

var menuBut = {
	imgInd: 1,
	action: function(){
		//load menu
	}
};
var restartBut = {
	imgInd: 2,
	action: function(){
		loadLevel(false);
	}
};
var undoBut = {
	imgInd: 3,
	action: function(){
		//undo
	}
};
var hintsBut = {
	imgInd: 4,
	action: function(){
		//toggle hints
	}
};
var butts = [scrnBut, menuBut, restartBut, undoBut, hintsBut]; 

var butImg = document.createElement("img");
butImg.onload = setupGame();

function setupGame() 
{
	setTimeout(function () 
	{
		//find the zoom button
		for(var i = 0; i < butts.length; i+=1)
		{
			if(butts[i] === scrnBut)
			{
				SELECT_ZOOM_COL = i;
				break;
			}
		}
		
		
		//create canvases
		for(var i = 0; i < 3; i += 1)
		{
			var newCanv = document.createElement("canvas");
			
			newCanv.style = "z-index: " + i + "; position: absolute; left: 0px; top: 0px;";
			canv.push(newCanv);
			cx.push(newCanv.getContext("2d"));
			mainDiv.appendChild(newCanv);
		}

				
		
		//start looping
		animate();
	}, 300);

}
butImg.src = "buttons.png";
</script>

</body>

</html> 