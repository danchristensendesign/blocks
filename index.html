<!DOCTYPE html>
<html>



<body>

<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

<div id="canvDiv" class="unselectable" style="position:absolute;">
	<canvas id="backCanv" style="position: absolute; left: 0; top: 0; z-index: 0;"></canvas>
	<canvas id="midCanv" style="position: absolute; left: 0; top: 0; z-index: 1;"></canvas>
	<canvas id="frontCanv" oncontextmenu="return false;" style="position: absolute; left: 0; top: 0; z-index: 2;"></canvas>	
</div>



<script>


const DOWN = 0;
const MOVE = 1;
const UP = 2;
var fullS = false;
//const BUTTON = -1;
const outGap = 7;
const inGap = 5;
var numX = 6;
var numY = 11;
var screenL;
var screenT;
var screenW;
var screenH;
var sMaj;
var sMin;
var flipped;
const scrollAmt = 150;
var mainDiv = document.getElementById("canvDiv");
mainDiv.style.left = 0 + 'px';
mainDiv.style.top = 0 + 'px';
var backCanv = document.getElementById("backCanv");
var backCx = backCanv.getContext("2d");
var midCanv = document.getElementById("midCanv");
var midCx = midCanv.getContext("2d");
var frontCanv = document.getElementById("frontCanv");
var frontCx = frontCanv.getContext("2d");
midCx.fillStyle = 'RGB(25,124,247)';
backCx.fillStyle = 'RGB(0,0,0)';
document.addEventListener("touchstart", updateClickM);
document.addEventListener("touchend", updateClickM);
document.addEventListener("touchmove", updateClickM, {passive: false});

document.addEventListener("mousedown", updateClickM);
document.addEventListener("mousemove", updateClickM);
document.addEventListener("mouseup", updateClickM);

var curRow = null;
var curCol = null;

const BUTTON = -1;
const ZOOM = 2; 
const TARGET = 3;
var act = null;
/* function updateClick(e)
{
	if(e.type === "touchend" || !(e.touches)) act = null;
	else act = BUTTON; 

	
} */
var targCen = [null, null];
var targPos = [null, null];
const targCircR = 35;
const targInR = 75;
const targOutR = 110;

var pos = [2,2];
function updateClickM(e)
{
	//console.log(e);
	//ignore defaults if we're not zooming
	if(e.type.indexOf('move') > -1 && act !== ZOOM) e.preventDefault();
	
	//get the position
	var XY = getXY(e);

	
	
	//check for new event
	if(XY[2] === DOWN)
	{
		console.log('down');
		//check for button
		if(XY[1] >= sMaj - butS)
		{
			act = BUTTON;
			console.log('but');

			//check for zoom button
			if(Math.floor(XY[0]/butS) === ZOOM_COL)
			{
				console.log('zoom');
				act = ZOOM;
				window.scrollTo(0, 0);
				reConfigure();
			}			
		}
		//otherwise it's a new target
		else
		{
			targCen = XY.slice(0, 2);
			console.log('board');
			act = TARGET;
		}
	}
	
	//check for event end, apply whatever is necessary
	if(XY[2] === UP)
	{		
		if(act === ZOOM)
		{
			fullS = !fullS;
			var elem = document.documentElement;

			/* View in fullscreen */
			if(fullS)
			{
			  if (elem.requestFullscreen) elem.requestFullscreen();
			  else if (elem.mozRequestFullScreen) elem.mozRequestFullScreen();
			  else if (elem.webkitRequestFullscreen) elem.webkitRequestFullscreen();
			  else if (elem.msRequestFullscreen) elem.msRequestFullscreen();
			}
			else
			{
				if (document.exitFullscreen) document.exitFullscreen();
				else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
				else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
				else if (document.msExitFullscreen)  document.msExitFullscreen();
			}
		}
			
		
		else if(!act === ZOOM && curRow !== null && curCol !== null)
		{
			if(act === TARGET)
			{
				
			}
			else
			{
				
			}
		}
		curRow = null;
		curCol = null;
		console.log('up');
		act = null;
	}
	
	//otherwise, it's a start or move, update where we're at
	else
	{
		//zoom-- make sure it's highlighted regardless of position
		if(act === ZOOM)
		{
			curRow = BUTTON;
			curCol = ZOOM_COL;
		}
		else
		{
			
			curRow = null;
			curCol = null;
			
			if(act === BUTTON)
			{
				
				if(XY[1] >= (sMaj - butS))
				{
					
					curRow = BUTTON;
					curCol = Math.floor(XY[0]/butS);
					console.log(curRow + ', ' + curCol + act);//XY[1] + ', poop ' + (sMaj - butS));
					if(curCol === ZOOM_COL)
					{
						console.log('bad zoom');
						curCol = null;
					}
				}
			}
			else if(act === TARGET)
			{
				targPos = XY.slice(0, 2);
				/* var dist = distance(targCen, XY);
				if(dist < targRin) targRing = 0&& XY[0] > startMin && XY[0] < sMin - startMin && 
				XY[1] > startMaj && XY[1] < sMaj - butS - startMaj)
			{
				curCol = Math.floor((XY[0] - startMin)/(boxS + inGap));
				curRow = Math.floor((XY[1] - startMaj)/(boxS + inGap));
				 */
			}
		}
	}
	//console.log(act);
}




/* function updateClick(e)
{
	//ignore defaults if we're not zooming
	//if(act !== ZOOM) e.preventDefault();
	
	//get the position
	var XY = getXY(e);
	console.log(XY[0] + ', ' + XY[1]);
	
	//check for new event
	if(e.type === "touchstart")
	{
		//check for button
		if(curY >= sMaj - butS)
		{
			act = BUTTON;

			//check for zoom button
			if(!butts[Math.floor(curX/butS)].prevent)
			{
				
				act = ZOOM;
				window.scrollTo(0, 0);
				reConfigure();
			}			
		}
		//otherwise it's a new target
		else
		{
			act = TARGET;
		}
	}
	
	//check for event end, apply whatever is necessary
	if(e.type === "touchend" || !(e.touches))
	{		
		if(!act === ZOOM && curRow !== null && curCol !== null)
		{
			if(act === TARGET)
			{
				
			}
			else
			{
				
			}
		}
		curRow = null;
		curCol = null;
		act = null;
	}
	
	//otherwise, it's a start or move, update where we're at
	else
	{
		//zoom-- make sure it's highlighted regardless of position
		if(act === ZOOM)
		{
			curRow = BUTTON;
			curCol = ZOOM_COL;
		}
		else
		{
			
			curRow = null;
			curCol = null;
			
			if(act === BUTTON && curY >= sMaj - butS)
			{
				curRow = BUTTON;
				curCol = Math.floor(curX/butS);
				if(curCol === ZOOM_COL) curCol == null;
			}
			else if(act === TARGET && curX > startMin && curX < sMin - startMin && 
				curY > startMaj && curY < sMaj - butS - startMaj)
			{
				curCol = Math.floor((curX - startMin)/(boxS + inGap));
				curRow = Math.floor((curY - startMaj)/(boxS + inGap));
				
			}
		}
	}
} */



function getXY(e)
{
	var x;
	var y;
	var type;
	
	if(e.type.substr(0, 5) === 'mouse') 
	{
		switch(e.type)
		{
			case 'mousedown': type = DOWN; break;
			case 'mousemove': type = MOVE; break;
			case 'mouseup': type = UP; break;	
		}
		
		
		
		x = e.clientX;
		y = e.clientY;
		
	}
	else
	{
		switch(e.type)
		{
			case 'touchstart': type = DOWN; break;
			case 'touchmove': type = MOVE; break;
			case 'touchend': return [0, 0, UP]; break;
		}
		/*x = e.touches[0].pageX - screenL;
		y = e.touches[0].pageY - screenT; */
		x = e.touches[0].clientX;
		y = e.touches[0].clientY;
		
	}
	
	if(flipped) 
	{
		return [sMin - y, x, type];
	}
	else
	{
		return [x, y, type];
	}
	
	/* if(flipped) 
	{
		return [sMin - (y - screenT), x - screenL, type];
	}
	else
	{
		return [x - screenL, y - screenT, type];
	} */
}


/* function updateClick(e)
{
	if(e.type === "touchend" || !(e.touches))
	{
		toggling = false;
		
		//do action if applicable
		if(curRow !== null && curCol !== null)
		{
			
		}
		curRow = null;
		curCol = null;
	}
	else
	{
		curRow = null;
		curCol = null;
		var curX, curY;
		
		if(flipped) 
		{
			curX = sMin - (e.touches[0].pageY - screenT);
			curY = e.touches[0].pageX - screenL;
		}
		else
		{
			curX = e.touches[0].pageX - screenL;
			curY = e.touches[0].pageY - screenT;
		}
		
		//on button target
		if(curY >= sMaj - butS)
		{
			curRow = BUTTON;
			if(butS) curCol = Math.floor(curX/butS);
			
			if(e.type === "touchstart" && !butts[curCol].prevent)
			{
				toggling = true;
				window.scrollTo(0, 0);
				reConfigure();
			}
			
		}
	
		//on grid target
		else if(curX > startMin && curX < sMin - startMin && 
				curY > startMaj && curY < sMaj - butS - startMaj)
		{
			curCol = Math.floor((curX - startMin)/(boxS + inGap));
			curRow = Math.floor((curY - startMaj)/(boxS + inGap));
			
		}
	}
	if(!toggling) e.preventDefault();
} */
function reConfigure()
{
	screenT = (window.pageYOffset || document.documentElement.scrollTop);
	window.scrollTo(0, (screenT)? scrollAmt: 0);
	
	screenT = (window.pageYOffset || document.documentElement.scrollTop);
	screenL = (window.pageXOffset || document.documentElement.scrollLeft);
	
	screenW = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);
	screenH = (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight);
	backCanv.width = screenW + scrollAmt;
	backCanv.height = screenH +  scrollAmt;
	midCanv.width = screenW + scrollAmt;
	midCanv.height = screenH + scrollAmt;
	frontCanv.width = screenW + scrollAmt;
	frontCanv.height = screenH + scrollAmt;
	backCx.restore();
	midCx.restore();
	frontCx.restore();
	backCx.save();
	midCx.save();
	frontCx.save();
	sMaj = Math.max(screenW, screenH);
	sMin = Math.min(screenW, screenH);
	flipped = (screenW > screenH);
	
	butS = sMin / butts.length;
	boxS = Math.min((sMaj - butS - 2 * outGap - (numY-1) * inGap)/numY, 
					(sMin - 2 * outGap - (numX-1) * inGap)/numX);
					
	startMin = (sMin - boxS * numX - (numX - 1) * inGap)/2;
	startMaj = (sMaj - butS - boxS * numY - (numY -1) * inGap)/2;
	
	drawBase();
}
	
function drawBase()
{
	backCx.clearRect(0, 0, backCanv.width, backCanv.height);
	frontCx.clearRect(0, 0, backCanv.width, backCanv.height);
	
	backCx.translate(0, screenT);
	frontCx.translate(0, screenT);
	midCx.translate(0, screenT);
	
	midCx.fillStyle = 'RGB(25,124,247)';
	
	if(flipped)
	{
		backCx.rotate(-Math.PI/2);
		backCx.translate(-sMin, 0);
		
		midCx.rotate(-Math.PI/2);
		midCx.translate(-sMin, 0);
		
	}
	for(var i = 0; i < butts.length; i += 1)
	{
		
		
		if(!flipped)
		{
			frontCx.drawImage(butImg, butts[i].imgInd * butImg.height, 0, butImg.height, butImg.height,
				butS * i, sMaj - butS, butS, butS);
		}
		else
		{
			frontCx.drawImage(butImg, butts[i].imgInd * butImg.height, 0, butImg.height, butImg.height,
						 sMaj - butS, sMin - butS * (i + 1), butS, butS);
		}
	}
	
		
	for(var i = 0; i < numX; i += 1)
	{
		for(var j = 0; j < numY; j += 1)
		{
			backCx.fillRect(startMin + i * (boxS + inGap), startMaj + j * (boxS + inGap), boxS, boxS);
		}
	}
	
	//drawPicker();	
	
	
}
var minR = 30;
var cX = sMin/2;
var cY = sMaj/2;
function drawPicker()
{
	backCx.fillStyle = 'RGB(100,100,100)';
	backCx.strokeStyle = 'RGB(100, 100, 100)';
	backCx.beginPath();
	
	cX = sMin/2;
	cY = sMaj/2;
	var gap = 3;
	var halfGap = gap/2;
	
	//backCx.globalAlpha = .8;
	backCx.fillStyle = 'RGB(200,200,200)';
	backCx.strokeStyle = 'RGB(0,0,0)';
	backCx.lineWidth = gap;
	backCx.arc(cX, cY, minR * 3, 0, 2 * Math.PI);
	backCx.fill();
	backCx.stroke();
	backCx.beginPath();
	backCx.arc(cX, cY, minR * 2, 0, 2 * Math.PI);
	backCx.stroke();
	
	for(var grp = 0; grp < 2; grp+= 1)
	{
		var outR;
		var inR;
		
		if(!grp)
		{
			outR = 2 * minR - halfGap;
			inR = minR + halfGap;
		}
		else
		{
			outR = 3 * minR - gap;
			inR = 2 * minR + halfGap;
		}
		var theta = Math.PI/8;
		var thetaInc = Math.PI/4;
		
		for(var slice = 0; slice < 4; slice+=1 )
		{
			theta += thetaInc;
			var dX = 3 * minR * Math.cos(theta);
			var dY = 3 * minR * Math.sin(theta);
			backCx.beginPath();
			backCx.moveTo(cX + dX, cY - dY);
			backCx.lineTo(cX - dX, cY + dY);
			backCx.stroke();
		}
	}
	
	backCx.beginPath();
	backCx.arc(cX, cY, minR, 0, 2 * Math.PI);
	backCx.fill();
	backCx.stroke();
}

var k = 0;

function animate()
{
	
	
	var curL = (window.pageXOffset || document.documentElement.scrollLeft);
	var curT = (window.pageYOffset || document.documentElement.scrollTop);
	var curW = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth);
	var curH = (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight);
	
	if(act !== ZOOM && (curL !== screenL || curT !== screenT || curW !== screenW || curH !== screenH))
	{
		console.log('change');
		reConfigure();
	}
	
	midCx.clearRect(0,0,sMin, sMaj);
	midCx.fillStyle = 'RGB(25,124,247)';
	if(act !== null)
	{
		midCxfont="30px";
		
		if(act === BUTTON || act === ZOOM)
		{
			if(curRow === BUTTON && curCol !== null)
			{
				midCx.fillRect(curCol * butS, sMaj - butS, butS, butS);
			}
		}
		else
		{
			const targCircT = boxS/2;
			const targInT = targCircT + boxS;
			const targOutT = targInT + boxS;
			
			
			midCx.fillStyle = 'RGB(25,124,247)';
			midCx.fillRect(startMin + pos[1] * (boxS + inGap), startMaj + pos[0] * (boxS + inGap), boxS, boxS);
			for(var s = 0; s < 8; s+= 1)
			{
				for(var r = 1; r < 3; r += 1)
				{
					var cos = Math.cos(s * Math.PI/4);
					var xSgn = (cos > 0)? 1: -1;
					var xVal = ((Math.abs(cos) > .7)? r: 0) * xSgn;
					var sin = Math.sin(s * Math.PI/4);
					var ySgn = (sin > 0)? 1: -1;
					var yVal = ((Math.abs(sin) > .7)? r: 0) * ySgn;
					midCx.fillRect(startMin + (pos[0] + xVal) * (boxS + inGap), startMaj + (pos[1] + yVal) * (boxS + inGap), boxS, boxS);
				}
			}
			
					
					
			var dist = distance(targPos, targCen);
			var rC = boxS/2;
			var ri = rC + boxS;
			var ro = ri + boxS;
			var theta = Math.atan2(targPos[1]-targCen[1], targPos[0]-targCen[0]);
			if(theta < 0) theta += Math.PI * 2;
			theta += Math.PI/8;
			var sect = Math.floor(theta/(Math.PI/4))%8;
			var sAng = -Math.PI/8 + sect * Math.PI/4;
			var eAng = sAng + Math.PI/4;
			var oR = 0;
			var iR = 0
			var scl;
			if(dist < targCircT)
			{
				scl = 0;
			}
			else if(dist < targInT)
			{
				scl = 1;	
			}
			else if(dist < targOutT) 
			{
				scl = 2;
			}
			var cos = Math.cos(sect * Math.PI/4);
			var xSgn = (cos > 0)? 1: -1;
			var xVal = ((Math.abs(cos) > .7)? scl: 0) * xSgn;
			var sin = Math.sin(sect * Math.PI/4);
			var ySgn = (sin > 0)? 1: -1;
			var yVal = ((Math.abs(sin) > .7)? scl: 0) * ySgn;
			midCx.fillStyle = 'RGB(255,255,255)';
			midCx.fillRect(startMin + (pos[0] + xVal) * (boxS + inGap), startMaj + (pos[1] + yVal) * (boxS + inGap), boxS, boxS);
			
			midCx.fillStyle = 'RGB(25,124,247)';
			midCx.beginPath();
			midCx.arc(targCen[0], targCen[1], oR, sAng, eAng);
			midCx.arc(targCen[0], targCen[1], iR, eAng, sAng, true);
			midCx.fill();
			
			midCx.beginPath();
			midCx.arc(targCen[0], targCen[1], targCircR, 0, 2 * Math.PI);
			midCx.stroke();
			midCx.lineWidth = 3;
			midCx.fillStyle = 'RGB(255,255,255)';
			for(var s = 0; s < 8; s+= 1)
			{
				for(var r = 0; r < 2; r += 1)
				{
					var or, ir;
					if(!r)
					{
						or = targInR;
						ir = targCircR;
					}
					else
					{
						or = targOutR;
						ir = targInR;
					}
					var sang = -Math.PI/8 + s * Math.PI/4;
					var eang = sang + Math.PI/4;
					midCx.beginPath();
					midCx.arc(targCen[0], targCen[1], or, sang, eang);
					midCx.arc(targCen[0], targCen[1], ir, eang, sang, true);
					midCx.globalAlpha = .3;
					midCx.fill();
					midCx.globalAlpha = 1;
					midCx.stroke();
				}
			}
			var dist = distance(targPos, targCen);
			
			
			//midCx.strokeText(targCen[0] + ', ' + targCen[1], 2, 10);
			
			
			
			var theta = Math.atan2(targPos[1]-targCen[1], targPos[0]-targCen[0]);
			if(theta < 0) theta += Math.PI * 2;
			theta += Math.PI/8;
			var sect = Math.floor(theta/(Math.PI/4))%8;
			var sAng = -Math.PI/8 + sect * Math.PI/4;
			var eAng = sAng + Math.PI/4;
			var oR = 0;
			var iR = 0
			if(dist < targCircT)
			{
				sAng = 0;
				eAng = 2 * Math.PI;
				oR = targCircR;
				iR = 0;
			}
			else if(dist < targInT)
			{
				oR = targInR;
				iR = targCircR;	
			}
			else if(dist < targOutT) 
			{
				oR = targOutR;
				iR = targInR;
			}
			midCx.fillStyle = 'RGB(25,124,247)';
			midCx.beginPath();
			midCx.arc(targCen[0], targCen[1], oR, sAng, eAng);
			midCx.arc(targCen[0], targCen[1], iR, eAng, sAng, true);
			midCx.fill();
			
			midCx.beginPath();
			midCx.arc(targCen[0], targCen[1], targCircR, 0, 2 * Math.PI);
			midCx.stroke();
			midCx.lineWidth = 3;
			midCx.fillStyle = 'RGB(255,255,255)';
			for(var s = 0; s < 8; s+= 1)
			{
				for(var r = 0; r < 2; r += 1)
				{
					var or, ir;
					if(!r)
					{
						or = targInR;
						ir = targCircR;
					}
					else
					{
						or = targOutR;
						ir = targInR;
					}
					var sang = -Math.PI/8 + s * Math.PI/4;
					var eang = sang + Math.PI/4;
					midCx.beginPath();
					midCx.arc(targCen[0], targCen[1], or, sang, eang);
					midCx.arc(targCen[0], targCen[1], ir, eang, sang, true);
					midCx.globalAlpha = .3;
					midCx.fill();
					midCx.globalAlpha = 1;
					midCx.stroke();
				}
			}
			
			
			
			
			//midCx.fillRect(startMin + curCol * (boxS + inGap), startMaj + curRow * (boxS + inGap), boxS, boxS);
		}
	}	
/* 	midCx.clearRect(0,0, sMin, sMaj);
	k++;
	k = k % 5;
	//console.log(act);
	var t = (act === null)? 0: 2;
	midCx.fillStyle = 'rgb(90,90,90)';
	midCx.fillRect(t * butS, sMaj - butS, butS, butS); */
	//console.log(l);
		
	requestAnimationFrame(animate);
}

function distance(arr1, arr2)
{
	return Math.pow(Math.pow(arr1[0] - arr2[0], 2) + Math.pow(arr1[1] - arr2[1], 2) ,.5);
}
var scrnBut = {
	prevent: false,
	imgInd: 0,
	action: function(){
		//do nothing
	}
};
var ZOOM_COL = 0;
var menuBut = {
	prevent: true,
	imgInd: 1,
	action: function(){
		//load menu
	}
};
var restartBut = {
	prevent: true,
	imgInd: 2,
	action: function(){
		loadLevel(false);
	}
};
var undoBut = {
	prevent: true,
	imgInd: 3,
	action: function(){
		//undo
	}
};
var hintsBut = {
	prevent: true,
	imgInd: 4,
	action: function(){
		//toggle hints
	}
};
var butts = [scrnBut, menuBut, restartBut, undoBut, hintsBut]; 
var butImg = document.createElement("img");
butImg.onload = function() 
{
	setTimeout(function () 
	{
		backCx.save();
		/* for(var i = 0; i < butts.length; i += 1)
		{
			console.log(butts[i].prevent);
		} */
		animate();
	}, 300);
/* 	loaded += 1;
	if(loaded == 1) startIt(); */
}
butImg.src = "buttons.png";
</script>

</body>

</html> 